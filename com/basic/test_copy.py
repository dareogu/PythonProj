# -*- coding: utf-8 -*-

'''
@Time    : 2025/10/5 17:01
@Author  : Dareo Gu
@FileName: test_copy.py
@Software: PyCharm

浅拷贝和深拷贝

对于不可变数据来说深浅拷贝的结果一致会重新创一个数据的副本。
浅拷贝对于可变类型来说只会拷贝其元素的引用。
深拷贝对于可变元素来说会递归的整个重新创建一个原数据的副本。
'''
import copy

# 引用原始对象。这将新对象li2指向li1所指向的内存中的同一位置。因此，我们对li1所做的任何更改也会在li2中发生
li1 = [['a'], ['b'], ['c']]
li2 = li1
li1.append(['d'])
print(li2)  # => [['a'], ['b'], ['c'], ['d']]

# 创建原始对象的浅拷贝副本。
# 我们可以使用list构造函数来实现这一点。浅拷贝创建一个新对象，但是用对原始对象的引用填充它。
# 因此，向原始列表li3中添加新对象不会传播到li4中，但是修改li3中的一个对象将传播到li4
li3 = [['a'], ['b'], ['c']]
li4 = list(li3)
li3.append([4])
print(li4)  # => [['a'], ['b'], ['c']]
li3[0][0] = ['X']
print(li4)  # => [[['X']], ['b'], ['c']]

# 创建一个深拷贝副本。这是用copy.deepcopy完成的。
# 现在，这两个对象是完全独立的，并且对其中一个对象所做的更改不会对另外一个对象产生影响。
li5 = [['a'], ['b'], ['c']]
li6 = copy.deepcopy(li5)
li5.append([4])
li5[0][0] = ['X']
print(li6)  # => [['a'], ['b'], ['c']]
